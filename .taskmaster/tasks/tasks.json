{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project and Set Up Repository",
        "description": "Create the project repository, initialize backend (Flask or FastAPI), frontend (React or HTML/JS), and configure PostgreSQL database.",
        "details": "Set up version control (Git). Scaffold backend using Flask or FastAPI. Scaffold frontend using React or plain HTML/JS. Configure PostgreSQL connection. Set up environment variables for secrets and configuration. Ensure project structure supports modular development.",
        "testStrategy": "Verify repository cloning, backend and frontend startup, and database connectivity with test queries.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Git Repository and Initialize Version Control",
            "description": "Set up a new Git repository for the project, configure .gitignore, and make the initial commit.",
            "dependencies": [],
            "details": "Create a new directory for the project. Run 'git init' to initialize version control. Add a .gitignore file to exclude environment files, node_modules, __pycache__, and other build artifacts. Make an initial commit with the project structure and README.",
            "status": "done",
            "testStrategy": "Clone the repository to a separate location and verify that only intended files are tracked."
          },
          {
            "id": 2,
            "title": "Scaffold Backend with Flask or FastAPI",
            "description": "Set up the backend using either Flask or FastAPI, including basic app structure and initial endpoint.",
            "dependencies": [],
            "details": "Create a backend directory. Set up a Python virtual environment. Install Flask ('pip install flask') or FastAPI ('pip install fastapi uvicorn'). Create main.py with a minimal app and a root endpoint (e.g., '/' returning 'Hello World'). Ensure the backend can be started via 'flask run' or 'uvicorn main:app --reload'.",
            "status": "done",
            "testStrategy": "Run the backend server and verify the root endpoint returns the expected response in a browser or via curl."
          },
          {
            "id": 3,
            "title": "Scaffold Frontend with React or HTML/JS",
            "description": "Set up the frontend using React or plain HTML/JS, including initial structure and a test page.",
            "dependencies": [],
            "details": "Create a frontend directory. For React, use 'npx create-react-app' to scaffold the project. For HTML/JS, create index.html and supporting JS/CSS files. Add a simple landing page that displays a test message. Ensure the frontend can be started with 'npm start' (React) or served via a static server.",
            "status": "done",
            "testStrategy": "Start the frontend and verify the test page loads correctly in a browser."
          },
          {
            "id": 4,
            "title": "Configure PostgreSQL Database Connection",
            "description": "Set up PostgreSQL locally or via a cloud provider, and configure backend connection settings.",
            "dependencies": [],
            "details": "Install PostgreSQL and create a new database for the project. In the backend, install a database driver (e.g., psycopg2 for Flask, asyncpg for FastAPI). Add connection logic to main.py or a config module. Test the connection by running a simple query (e.g., SELECT 1).",
            "status": "done",
            "testStrategy": "Run backend code to connect and query the database. Verify successful connection and query execution."
          },
          {
            "id": 5,
            "title": "Set Up Environment Variables and Modular Project Structure",
            "description": "Configure environment variables for secrets and settings, and organize project files for modular development.",
            "dependencies": [],
            "details": "Create .env files for backend and frontend to store secrets (e.g., DB credentials, API keys). Use libraries like python-dotenv for backend and dotenv for frontend to load variables. Refactor backend and frontend code into modules (e.g., routes, models, components) to support scalable development.",
            "status": "done",
            "testStrategy": "Verify environment variables are loaded correctly and not committed to Git. Check that project structure allows for easy addition of new modules and features."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement User Authentication and Email Verification",
        "description": "Develop secure user registration, login, email verification, and password reset flows.",
        "details": "Use Flask-Login or FastAPI Users for authentication. Store hashed passwords using bcrypt or Argon2. Implement email verification by sending a unique token link. Add password reset via email with secure token. Enforce minimum 8-character alphanumeric passwords.",
        "testStrategy": "Unit test registration, login, email verification, and password reset endpoints. Attempt logins with unverified and verified emails. Test password reset with valid and invalid tokens.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Authentication Data Models",
            "description": "Define and implement database models for users, including fields for email, hashed password, email verification status, and password reset tokens.",
            "dependencies": [],
            "details": "Use SQLAlchemy or equivalent ORM to create the User model with fields: id, email, hashed_password, email_verified, and fields for storing verification and reset tokens as needed.",
            "status": "done",
            "testStrategy": "Run migration scripts and verify table creation. Insert and query test records for user registration, email verification, and password reset tokens."
          },
          {
            "id": 2,
            "title": "Implement Secure User Registration and Login",
            "description": "Develop endpoints for user registration and login using Flask-Login or FastAPI Users, ensuring password hashing with bcrypt or Argon2 and enforcing minimum 8-character alphanumeric passwords.",
            "dependencies": [
              "2.1"
            ],
            "details": "Validate registration input, hash passwords before storing, and use authentication middleware for login. Reject passwords not meeting complexity requirements.",
            "status": "done",
            "testStrategy": "Unit test registration and login endpoints with valid and invalid data. Attempt logins with correct and incorrect credentials."
          },
          {
            "id": 3,
            "title": "Develop Email Verification Flow",
            "description": "Implement email verification by generating a unique token, sending a verification link to the user's email, and verifying the token upon user action.",
            "dependencies": [
              "2.2"
            ],
            "details": "Generate secure, time-limited tokens for email verification. Integrate with an email provider to send verification links. Update user status upon successful verification.",
            "status": "done",
            "testStrategy": "Test email delivery, token validation, and status updates. Attempt logins with unverified and verified emails."
          },
          {
            "id": 4,
            "title": "Implement Password Reset via Email",
            "description": "Enable users to request a password reset by email, generate a secure reset token, and allow password update through a token-protected endpoint.",
            "dependencies": [
              "2.2"
            ],
            "details": "Create endpoints for requesting password reset and for submitting a new password. Ensure tokens are single-use and expire after a set period.",
            "status": "done",
            "testStrategy": "Test password reset requests with valid and invalid emails, token expiration, and password update flows."
          },
          {
            "id": 5,
            "title": "Integrate and Test Complete Authentication Flows",
            "description": "Combine registration, login, email verification, and password reset into a cohesive authentication system and perform end-to-end testing.",
            "dependencies": [
              "2.3",
              "2.4"
            ],
            "details": "Ensure all flows interact correctly, enforce security best practices, and handle edge cases such as repeated requests and invalid tokens.",
            "status": "done",
            "testStrategy": "Perform integration tests covering all authentication scenarios, including registration, login, verification, and password reset, with both valid and invalid inputs."
          }
        ]
      },
      {
        "id": 3,
        "title": "Design and Implement Database Schema",
        "description": "Create PostgreSQL tables for User, Property, Transaction, and NotificationLog models.",
        "details": "Define models: User (id, email, hashed_password, email_verified), Property (id, user_id, rent_amount, due_day, frequency, address, tenant_nickname), Transaction (id, property_id, date, amount, matched), NotificationLog (id, user_id, property_id, date_sent). Use SQLAlchemy or equivalent ORM for migrations.",
        "testStrategy": "Run migration scripts and verify table creation. Insert and query test records for each model.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Entity-Relationship Model",
            "description": "Analyze requirements and design the entity-relationship (ER) model for User, Property, Transaction, and NotificationLog, specifying relationships and cardinality.",
            "dependencies": [],
            "details": "Map out how User, Property, Transaction, and NotificationLog relate to each other, including foreign key relationships and required fields.",
            "status": "done",
            "testStrategy": "Review ER diagram for completeness and correctness with stakeholders."
          },
          {
            "id": 2,
            "title": "Specify Table Schemas and Constraints",
            "description": "Translate the ER model into detailed PostgreSQL table schemas, defining columns, data types, primary keys, foreign keys, and constraints for each model.",
            "dependencies": [
              "3.1"
            ],
            "details": "Ensure normalization (at least third normal form), add constraints (e.g., NOT NULL, UNIQUE), and avoid storing full addresses in a single field.",
            "status": "done",
            "testStrategy": "Validate schema definitions against requirements and best practices; peer review for normalization and constraint coverage."
          },
          {
            "id": 3,
            "title": "Implement Models Using ORM",
            "description": "Create SQLAlchemy (or equivalent ORM) model classes for each table, reflecting the defined schema and relationships.",
            "dependencies": [
              "3.2"
            ],
            "details": "Define Python classes for User, Property, Transaction, and NotificationLog with appropriate field types, relationships, and constraints.",
            "status": "done",
            "testStrategy": "Run ORM model validation and ensure models match the intended schema."
          },
          {
            "id": 4,
            "title": "Generate and Apply Database Migrations",
            "description": "Use the ORM's migration tool to generate migration scripts and apply them to create the actual PostgreSQL tables.",
            "dependencies": [
              "3.3"
            ],
            "details": "Generate migration scripts (e.g., with Alembic), review for accuracy, and apply to the development database.",
            "status": "done",
            "testStrategy": "Run migration scripts on a clean database and verify successful table creation."
          },
          {
            "id": 5,
            "title": "Verify Schema Functionality with Test Data",
            "description": "Insert and query test records for each model to ensure tables, relationships, and constraints function as intended.",
            "dependencies": [
              "3.4"
            ],
            "details": "Write and execute test scripts to insert, update, and query data, checking for constraint enforcement and relational integrity.",
            "status": "done",
            "testStrategy": "Automate tests to cover all CRUD operations and edge cases for each model."
          }
        ]
      },
      {
        "id": 4,
        "title": "Develop Property CRUD Functionality",
        "description": "Enable users to create, read, update, and delete rental property records.",
        "details": "Implement RESTful API endpoints for property CRUD. Validate input (rent amount, frequency, due day). Ensure properties are linked to authenticated users. Add frontend forms for property entry and editing.",
        "testStrategy": "Test API endpoints with valid and invalid data. Verify property visibility per user. UI tests for property add/edit/delete flows.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design RESTful API Endpoints for Property CRUD",
            "description": "Define and implement RESTful API endpoints to create, read, update, and delete rental property records, following standard HTTP methods (GET, POST, PUT/PATCH, DELETE).",
            "dependencies": [],
            "details": "Endpoints should include: GET /properties, POST /properties, GET /properties/:id, PUT/PATCH /properties/:id, DELETE /properties/:id. Ensure endpoints are structured for scalability and maintainability.",
            "status": "done",
            "testStrategy": "Verify each endpoint with valid and invalid requests. Confirm correct HTTP status codes and error handling."
          },
          {
            "id": 2,
            "title": "Implement Input Validation for Property Data",
            "description": "Add validation logic for property fields such as rent amount, frequency, and due day to ensure data integrity and prevent invalid submissions.",
            "dependencies": [
              "4.1"
            ],
            "details": "Use server-side validation to check for required fields, correct data types, and acceptable value ranges. Return standardized error responses for invalid input.",
            "status": "done",
            "testStrategy": "Test API endpoints with various valid and invalid payloads. Confirm validation errors are returned as expected."
          },
          {
            "id": 3,
            "title": "Enforce Property Ownership and User Authentication",
            "description": "Ensure that property records are linked to authenticated users and restrict CRUD operations to the owner of each property.",
            "dependencies": [
              "4.1"
            ],
            "details": "Integrate authentication middleware to verify user identity. Implement ownership checks so users can only access and modify their own properties.",
            "status": "done",
            "testStrategy": "Attempt CRUD operations as authenticated and unauthenticated users. Verify access control and property visibility per user."
          },
          {
            "id": 4,
            "title": "Develop Frontend Forms for Property Entry and Editing",
            "description": "Create user interface forms for adding and editing property records, integrating with the backend API and supporting validation feedback.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Design responsive forms for property creation and editing. Implement client-side validation and display server-side validation errors. Ensure seamless user experience.",
            "status": "done",
            "testStrategy": "Perform UI tests for property add/edit flows. Validate form behavior with correct and incorrect input."
          },
          {
            "id": 5,
            "title": "Test End-to-End Property CRUD Functionality",
            "description": "Conduct comprehensive testing of the property CRUD workflow, covering API, validation, authentication, and frontend integration.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Write and execute test cases for all CRUD operations, including edge cases and error scenarios. Verify data consistency and user-specific property access.",
            "status": "done",
            "testStrategy": "Run automated and manual tests for API endpoints and UI flows. Confirm correct behavior for property creation, reading, updating, and deletion."
          }
        ]
      },
      {
        "id": 5,
        "title": "Integrate Akahu Bank Feed",
        "description": "Connect to Akahu API to fetch and store recent bank transactions for rent matching.",
        "details": "Implement OAuth flow for Akahu account linking. Use Akahu API to pull transactions from the past 2 days. Store transactions securely in the database. Handle API errors and token refresh.",
        "testStrategy": "Mock Akahu API responses for development. Test account linking, transaction fetching, and error handling. Verify transactions are stored and associated with correct properties.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Akahu OAuth Account Linking",
            "description": "Develop the OAuth flow to allow users to securely link their Akahu account, obtaining and storing the necessary tokens for API access.",
            "dependencies": [],
            "details": "Register the application with Akahu to obtain App ID and Secret. Implement the OAuth2 authorization process, ensuring secure handling of secrets and redirect flows. Store user tokens securely for future API calls.",
            "status": "pending",
            "testStrategy": "Mock Akahu OAuth endpoints. Test account linking with valid and invalid credentials. Verify tokens are securely stored and retrievable."
          },
          {
            "id": 2,
            "title": "Fetch Recent Transactions from Akahu API",
            "description": "Use the Akahu API to retrieve bank transactions from the past 2 days for linked accounts.",
            "dependencies": [
              "5.1"
            ],
            "details": "Utilize the stored user tokens to call Akahu's transactions endpoint, filtering for transactions within the last 2 days. Ensure API requests are authenticated and paginated as needed.",
            "status": "pending",
            "testStrategy": "Mock Akahu transaction responses. Test fetching with various date ranges and account scenarios. Validate correct API usage and data retrieval."
          },
          {
            "id": 3,
            "title": "Store Transactions Securely in Database",
            "description": "Persist the fetched transactions in the database, associating them with the correct user and property records.",
            "dependencies": [
              "5.2"
            ],
            "details": "Map Akahu transaction data to the Transaction model. Ensure transactions are linked to the correct Property and User. Handle duplicate transaction prevention and data integrity.",
            "status": "pending",
            "testStrategy": "Insert mock transactions and verify correct storage, association, and deduplication. Query database to confirm data integrity."
          },
          {
            "id": 4,
            "title": "Handle Akahu API Errors and Token Refresh",
            "description": "Implement robust error handling for Akahu API failures and automate token refresh when required.",
            "dependencies": [
              "5.2"
            ],
            "details": "Detect and log API errors, including authentication failures, rate limits, and network issues. Implement token refresh logic per Akahu's OAuth2 protocol and retry failed requests as appropriate.",
            "status": "pending",
            "testStrategy": "Simulate API errors and expired tokens. Verify error logging, user notification (if needed), and successful token refresh and retry."
          },
          {
            "id": 5,
            "title": "Verify End-to-End Integration and Data Association",
            "description": "Test the complete flow from account linking to transaction storage, ensuring transactions are correctly matched for rent purposes.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Perform integration tests covering OAuth linking, transaction fetching, error handling, and database storage. Confirm that transactions are associated with the correct properties and ready for rent matching logic.",
            "status": "pending",
            "testStrategy": "Run end-to-end tests with mocked Akahu responses. Validate that transactions appear in the database and are linked to the correct user and property. Check for edge cases and data consistency."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Rent Matching Logic",
        "description": "Develop logic to match incoming transactions to expected rent payments for each property.",
        "details": "For each property, check if a transaction with matching amount (within margin) and date (±1 day of due date) exists. Mark as matched or missed. Allow user override for mismatches. Store match status in Transaction and Property models.",
        "testStrategy": "Unit test matching logic with various edge cases (partial payments, late payments, overpayments). Simulate user overrides and verify updates.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Schedule and Run Daily Rent Check Job",
        "description": "Set up a scheduled job (cron or Celery) to run daily at 8:00 AM NZST to check for missed rent.",
        "details": "Configure scheduler to trigger rent check logic for all properties. Ensure timezone is set to NZST. Use Railway or Fly.io scheduler, or deploy as a managed cron job. Log job runs and errors.",
        "testStrategy": "Test job execution at correct time and timezone. Simulate missed and received payments and verify detection. Check logs for job status.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Email Notification System",
        "description": "Send email alerts to users when rent is missed, using SMTP or transactional email provider.",
        "details": "Integrate with Postmark, SendGrid, or SMTP. Compose professional, friendly email templates. Trigger email on missed rent detection. Log notifications in NotificationLog table. Handle email delivery errors.",
        "testStrategy": "Send test emails via provider sandbox. Verify email content, delivery, and logging. Simulate delivery failures and check error handling.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build Mobile-First Frontend Dashboard",
        "description": "Develop a clean, minimal dashboard for property management and rent status visibility.",
        "details": "Design responsive UI with clear indicators for rent received/missed. Implement property list, add/edit forms, and rent status display. Use token-style visual timeline for payments as a placeholder for future enhancements.",
        "testStrategy": "Manual and automated UI tests on mobile and desktop. Verify clarity of rent status and usability of property management flows.",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Deploy Application with SSL and NZ Timezone Alignment",
        "description": "Deploy backend and frontend to Railway or Fly.io with SSL (Let's Encrypt) and ensure NZ timezone alignment.",
        "details": "Set up CI/CD pipeline for deployment. Configure Let's Encrypt SSL certificates. Set server timezone to NZST. Verify Akahu and email integrations work in production. Ensure data residency and compliance as feasible.",
        "testStrategy": "End-to-end smoke tests in production. Verify SSL, correct timezone in logs and emails, and full user flow from registration to notification.",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-16T03:58:33.712Z",
      "updated": "2025-08-16T05:13:51.170Z",
      "description": "Tasks for master context"
    }
  }
}